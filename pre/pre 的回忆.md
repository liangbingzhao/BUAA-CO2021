# pre 的回忆

## 选填

错了俩，这个无关紧要了，大家错的差不多多

## logisim

#### 一、题目概述

|  I/O  |  位数  |
| :---: | :----: |
| grade | [31:0] |
|   R   | [7:0]  |
|  out  | [3:0]  |

- grade：有四个同学的成绩，每个人的成绩是8位，成绩里面低四位是四个题的通过与否，1是通过，0是没通过，这四个题要至少通过两个才行， 高八位是必做题的做题情况，详见R
- R：可通过此判断哪个是必做题，其形式为 ex：11011111，这代表第六个题为必做题。同学的高四位中，这个必做题必须为1才行
- out：四个人的通过情况，第0位是第一个同学的通过情况，第1位是第二个，以此类推
- 同学的通过判定：首先要前四题至少有两个通过，其次是必做题必须对



#### 二、我的思路

用bit finder找到必做题，然后用shifter变成8位的只有必做那儿为1的数，与原数进行and操作，只要大于0就说明必做题过了；前面四位每个拆开与1进行and操作，把四个加起来，大于等于2就说明前四题至少过俩。最后and起来就是这位同学的通过情况，四个同学的用splitter连起来就是答案。



## verilog

#### 一、题目描述

字符检测机，检测连续的cscore（或者大写的）有多少个，不同的cscore之间只允许存在空格，中间出现任何其他字符，out清零。**异步置零**

#### 二、注意点（我没做出来，一直compile error）

- 异步置零：看[这儿](http://www.51hei.com/mcu/3801.html)
- 坑点：因为有两个c，所以写case的时候要按照cscsore的逻辑写



## mips

#### 一、题目

这就是个极其简单的翻译题，不涉及dfs的翻译题，c语言程序是最长连续递增序列，要求翻译成mips

#### 二、无：）

